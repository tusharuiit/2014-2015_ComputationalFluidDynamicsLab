#include <stdio.h>
#include "helper.h"
#include "visualLB.h"
#include "computeCellValues.h"
#include "LBDefinitions.h"
#include <mpi.h>

void write_vtkHeader( FILE *fp, int * local_xlength )
{
    if( fp == NULL )
    {
        char szBuff[80];
        sprintf( szBuff, "Null pointer in write_vtkHeader" );
        ERROR( szBuff );
        return;
    }

    fprintf(fp,"# vtk DataFile Version 2.0\n");
    fprintf(fp,"generated by CFD-lab course output (written by Tobias Neckel) \n");
    fprintf(fp,"ASCII\n");
    fprintf(fp,"\n");
    fprintf(fp,"DATASET STRUCTURED_GRID\n");
    fprintf(fp,"DIMENSIONS  %i %i %i \n", local_xlength[0], local_xlength[1], local_xlength[2]);
    fprintf(fp,"POINTS %i float\n", (local_xlength[0]) * (local_xlength[1]) * (local_xlength[2]));
    fprintf(fp,"\n");
}

void write_vtkPointCoordinates( FILE *fp, int *xlength, int * local_xlength, int iCoord, int jCoord, int kCoord, int iProc, int jProc, int kProc)
{
    double originX, originY, originZ;

    originX = (double) iCoord * (xlength[0] / iProc);
    originY = (double) jCoord * (xlength[1] / jProc);
    originZ = (double) kCoord * (xlength[2] / kProc);

    int x = 0;
    int y = 0;
    int z = 0;

    for(z = 1; z <= local_xlength[2]; z++)
        for(y = 1; y <= local_xlength[1]; y++)
            for ( x = 1; x <= local_xlength[0]; x++)
                fprintf(fp, "%f %f %f\n", originX+(double) x , originY + (double) y,  originZ + (double) z);


}


void writeVtkOutput(const double * const collideField, const int * const flagField, const char * filename, unsigned int t, int *xlength, int * local_xlength, int rank, int iCoord, int jCoord, int kCoord, int iProc, int jProc, int kProc)
{
    int x, y, z, currentCellIndex;
    double cellVelocity[3], cellDensity;

    char szFileName[80];
    FILE *fp=NULL;
    sprintf( szFileName, "%sProcess%d.%i.vtk", filename, rank, t );
    fp = fopen( szFileName, "w");
    if( fp == NULL )
    {
        char szBuff[80];
        sprintf( szBuff, "Failed to open %s", szFileName );
        ERROR( szBuff );
        return;
    }

    write_vtkHeader( fp, local_xlength);
    write_vtkPointCoordinates(fp, xlength, local_xlength, iCoord, jCoord, kCoord, iProc, jProc, kProc);

    fprintf(fp,"POINT_DATA %i \n", (local_xlength[0]) * (local_xlength[1]) * (local_xlength[2]));

    fprintf(fp,"\n");
    fprintf(fp, "VECTORS velocity float\n");
    for(z = 1; z <= local_xlength[2]; z++)
        for (y = 1; y <= local_xlength[1]; y++)
            for (x = 1; x <= local_xlength[0]; x++)
            {
                currentCellIndex = PARAMQ * (z * (local_xlength[0] + 2) * (local_xlength[1] + 2) + y * (local_xlength[0] + 2) + x);
                computeDensitySSE(collideField + currentCellIndex, &cellDensity);
                computeVelocity(collideField + currentCellIndex, &cellDensity, cellVelocity);
                fprintf(fp, "%f %f %f\n", cellVelocity[0], cellVelocity[1], cellVelocity[2]);
            }


    fprintf(fp,"\n");

    fprintf(fp, "SCALARS density float 1 \n");
    fprintf(fp, "LOOKUP_TABLE default \n");
    for(z = 1; z <= local_xlength[2]; z++)
        for(y = 1; y <= local_xlength[1]; y++)
            for (x = 1; x <= local_xlength[0]; x++)
            {
                currentCellIndex = PARAMQ * (z * (local_xlength[0] + 2) * (local_xlength[1] + 2) + y * (local_xlength[0] + 2) + x);
                computeDensitySSE(collideField + currentCellIndex, &cellDensity);
                fprintf(fp, "%f\n", cellDensity);
            }

//    fprintf(fp, "SCALARS boundaryType integer 1 \n");
//    fprintf(fp, "LOOKUP_TABLE default \n");
//    for(z = 0; z <= local_xlength[2] + 1; z++)
//        for(y = 0; y <= local_xlength[1] + 1; y++)
//            for (x = 0; x <= local_xlength[0] + 1; x++)
//            {
//                currentCellIndex = (z * (local_xlength[0] + 2) * (local_xlength[1] + 2) + y * (local_xlength[0] + 2) + x);
//                fprintf(fp, "%d\n", flagField[currentCellIndex]);
//            }



    if( fclose(fp) )
    {
        char szBuff[80];
        sprintf( szBuff, "Failed to close %s", szFileName );
        ERROR( szBuff );
    }
}

void MPI_writeVtkOutput( MPI_File *fh, const double * const collideField, const int * const flagField, int * local_xlength,
			 int iCoord, int jCoord, int kCoord, int iProc, int jProc, int kProc, int *xlength)
{

    double *dataset = (double*) malloc( (size_t)(local_xlength[0] * local_xlength[1] * local_xlength[2] * 7) * sizeof(double));

    double originX, originY, originZ;

    int x, y, z, i = 0, currentCellIndex;

    double cellDensity, cellVelocity[3];

    MPI_Status status;

    originX = (double) iCoord * (xlength[0]/iProc);
    originY = (double) jCoord * (xlength[1]/jProc) ;
    originZ = (double) kCoord * (xlength[2]/kProc);

    for(z = 1; z <= local_xlength[2]; z++)
        for(y = 1; y <= local_xlength[1]; y++)
            for ( x = 1; x <= local_xlength[0]; x++){

                currentCellIndex = PARAMQ * (z * (local_xlength[0] + 2) * (local_xlength[1] + 2) + y * (local_xlength[0] + 2) + x);

                computeDensitySSE(collideField + currentCellIndex, &cellDensity);
                computeVelocity(collideField + currentCellIndex, &cellDensity, cellVelocity);

                dataset[i] = originX + (double)x;
                dataset[i+1] = originY + (double)y;
                dataset[i+2] = originZ + (double)z;

                dataset[i+3] = cellVelocity[0];
                dataset[i+4] = cellVelocity[1];
                dataset[i+5] = cellVelocity[2];

                dataset[i+6] = cellDensity;

                i = i + 7;

            }

    MPI_File_write_shared( *fh, dataset, local_xlength[0] * local_xlength[1] * local_xlength[2] * 7, MPI_DOUBLE, &status);

}

